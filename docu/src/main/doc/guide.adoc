= ??? Serializer
Eclipse Foundation <john.doe@acme.com>
v???, ??/??/2023

== Introduction

The Eclipse Serializer (FIXME ???) project allows you to serialize and deserialize any object or object graph to a binary format.

In contrast to the Java Standard Serialization, no specific interface is required. Also, no annotations or predefined schema are required.

The deserialization also does not execute the constructor nor any other method of the deserialized class so there is no risk of any deserialization vulnerabilities.  The process just puts the data into the JVM heap in the format of the JVM object. If any tampering is done by replacing the serialized content with data from other classes, no malicious code can be executed and your program will fail when trying to access the new instance (because the classes don't match)

Other available functionality

- Specific handlers for 'recent' added immutable collections of JDK can be activated.
- Support for circular references
- Ability to use bytes generated by the previous version of your class (data migration and refactoring support)
- Customizable field exclusion
- Custom Type handlers

NOTE: This project is also the basis for the Eclipse Stream (FIXME ??? use final name) as this serialization engine powers the Native Java Data Store for developing ultra-fast Java in-memory database applications.

== Setup

To have the functionality available within your application, add the following dependency. When using maven, you can use

FIXME ??? Use final artifact name and version number

[pom.xml]
----
    <dependency>
        <groupId>org.eclipse.microstream.serializer</groupId>
        <artifactId>microstream-serializer</artifactId>
        <version>1.0.0</version>
    </dependency>
----

If you want to make use of the special binary handlers (see further), you can add the following artifacts

[pom.xml]
----
    <dependency>
        <groupId>org.eclipse.microstream.serializer</groupId>
        <artifactId>microstream-serializer-persistence-binary-jdk8</artifactId>
        <version>1.0.0</version>
    </dependency>
----

[pom.xml]
----
    <dependency>
        <groupId>org.eclipse.microstream.serializer</groupId>
        <artifactId>microstream-serializer-persistence-binary-jdk17</artifactId>
        <version>1.0.0</version>
    </dependency>
----

== Supported Environments and Versions

The code base is compiled with JDK 11 binaries and can be used by JDK 11 or any higher version of the JVM. But code is not limited to Java but can be used in any JVM based language like Groovy, Scala, Android and Kotlin.

== Your First Serialization

Now that you have added the required dependency, you can start making use of the Serializer functionality.

Suppose that you have an `Address` class with the typical fields and also `Person` with its properties and a reference to an `Address` instance.

The following snippet converts this Object Graph to a byte array.

[example.java]
----
    SerializerFoundation<?> foundation = SerializerFoundation.New();
    byte[] bytes;
    try (Serializer<byte[]> serializer = Serializer.Bytes(foundation)) {
        bytes = serializer.serialize(person);
    }
----

The `SerializerFoundation` instance can be used to customize the serializer process. We will cover this later in this guide.

== Deserializing

When you have your data in a binary format, you can recreate your instances by using the _deserialize_ method.

[example.java]
----
    Person newPerson;
    try (Serializer<byte[]> serializer = Serializer.Bytes(foundation)) {
         newPerson = serializer.deserialize(bytes);
    }
----

== Type Dictionary

The binary format does not contain any class information. That is, it doesn't contain the class name nor the property names of the original serialized class. The _Type Dictionary_ keeps track of this information and maps class names to unique type IDs.

A Type Dictionary is linked to a `SerializerFoundation` and this is important to know if you want to reuse the  `SerializerFoundation` or the `Serializer` instance.

Reusing a `Serializer` for multiple _serialize_ and/or _deserialize_ method calls is possible. And also creating multiple `Serializer` instances from a single `SerializerFoundation` is possible. But you need to know that they all share the same _Type Dictionary_. And every time it encounters a new Java class, it gets registered within the dictionary.

And so, the order the classes get registered, determines the assigned id. And when the number is different during deserialisation than serialisation, a problem arises.

One way to overcome this problem is always to create a new `SerializerFoundation` and `Serializer` instances.

== Registering types

To overcome the issue with the assigned IDs as described in the previous section, you can register classes so that the order is known and fixed. This way, you do not need to create new instances all the time and gain a little bit of performance.


[example.java]
----
    SerializerFoundation<?> foundation = SerializerFoundation.New();
    foundation.registerEntityTypes(Employee.class, Order.class);
----

Classes used by these _entity types_ are registered automatically since the object graph is determined during this registration as part of the registration. So, when determining the properties, it automatically registers any not yet-known classes.

== TypedSerializer Usage

An alternative for the registration of all the types is to make use of the `TypedSerializer`.  This time, the _Type Dictionary_ is included within the binary output.  So that when you deserialize, all information is available and no additional configuration is required.

The downside is that the size increases which is especially noticeable when you only serialize a 'small' Object graph.

== Specific Handlers

The conversion to and from the binary representation is performed by `PersistenceTypeHandler` s.  By default, there are specific type handlers for many types available and ready to use without any additional configuration. If there is no specific handler found for a certain type, a generic handler converts it.

This generic handler scans the class structure and serializes the properties of the object. In most cases this is fine but sometimes it doesn't result in efficient binary data or performance.

Therefore, you can register individual type Handlers, see sections later on, but there are also specialized handlers available for some JDK classes.  They are grouped into 2 artifacts.

- Handlers for JDK8 and classes introduced in older versions.
- Handlers for JDK 9 to 17 introduced classes.

As mentioned during the setup, they are in specific artifacts, called JDK8 and JDK17.  The registration can be done on the _SerializerFoundation_ as indicated in the snippet.

[example.java]
----
    BinaryHandlersJDK17.registerJDK17TypeHandlers(foundation);
----

== Unserialisable

There are a few classes that are marked as not serialisable. These cannot be converted to a binary format, mostly because they are associated with OS resources.  Here is an incomplete list

- ClassLoader
- Thread
- InputStream
- OutputStream
- FileChannel
- Socket
- ServerSocket
- Enumeration
- Iterator
- Throwable

If you have one of these classes within the object graph that you serialize, you get the `PersistenceExceptionTypeNotPersistable` exception.

Also, variables holding lambda expressions cannot be serialized due to the synthetic nature of these constructs.  The JVM does not provide enough tools to inspect and recreate such constructs.


[example.java]
----
    Function<Integer, Integer> func = (x) -> x * x;
    byte[] bytes = serializer.serialize(func);
----

The above will result in a `PersistenceException` exception where the message indicates that lambdas cannot be supported for the moment.

In general, this is not a real problem as most lambdas do not carry state that you like to persist. See the next section on how you can indicate that a variable of an instance needs to be ignored in such a case.
And if you do need to persist such types of constructs, you can always create a class that implements the functional interface.  These actual classes are handled properly.

== Exclude fields

As indicated in the previous section, sometimes you want to exclude some fields of a class from the serialisation process.

By default, the fields that have the `transient` keyword are not serialized. You can define your own class if you have some custom logic that you need. In that case, implement the `PersistenceFieldEvaluator` interface and register it on the _foundation_

[CustomFieldEvaluator.java]
----
    public class CustomFieldEvaluator implements PersistenceFieldEvaluator {

        @Override
        public boolean applies(Class<?> entityType, Field field) {
            // return true when fields need to be included, false if excluded.
        }
    }
----

[example.java]
----
    foundation.setFieldEvaluatorPersistable(new CustomFieldEvaluator());
----


Important notice about excluded fields. Since the Eclipse Serializer code bypasses the default Java way of initiating instances, those excluded fields have 'null' values instead of the value that is defined at the field.

For example, when  having the following definition

[example.java]
----
    private transient int ignored = 123;
----

The value of the variable _ignored_ is 0 (and not 123) when we deserialize the bytes. This is because no constructor nor field initialization is performed for security reasons.  And the not initialized value for a primitive integer is 0, for objects, it will be `null`.

== Data Model migration

The Eclipse Serializer (FIXME ??? change to final name) can read the data generated with a previous version of your class and load it into the new structure.

Suppose you have a case that you need to rename a few properties within a class, or add and remove a few properties.  This kind of refactoring is small refactoring and can be handled through a _Type Hander Mapper_ automatically when we make use of the `TypedSerializer`.

=== With `TypedSerializer`

In the first scenario, we assume that you made use of the `TypedSerializer`. In that case, the structure of the data in the binary format is included in the binary output itself, as we have discussed in the section on the `TypedSerializer` earlier on.

When the _deserialization_ process tries to map the info from the type dictionary that is saved together with the data, it detects that there is no 100% match between the info and the current structure of the class.

At that point, it tries to define a mapping between old, within the binary format, and the new, the current class structure, data.  This is done based on the properties name and the _Levenshtein_ word distance, see https://en.wikipedia.org/wiki/Levenshtein_distance[Wikipedia page].

Since refactoring is most of the time, reordering the properties and changing the name but portions are kept, the distance calculation yields in most cases a good result in matching the old to the new situation.

This mapping is applied automatically when the deserialization is performed. Make sure you always test this properly so that you are sure this kind of automatic mapping yields the expected result for your case.

NOTE: This automatic mapping cannot be used when we rename the class or move it to another package.

=== Custom Mapping

When you do not want to make use of the `TypedSerializer`, because it increases the binary output for example, you can define a custom Mapping in code and perform the loading 'semi automatical'.

But first of all, we need to know how the Type Handler has stored our instance.  In which order the properties are stored.  You can find that out after you have serialized an instance with the following code snippet.

[example.java]
----
     PersistenceTypeHandlerRegistry<Binary> registry = foundation.getTypeHandlerRegistry();
    long typeId = registry.lookupTypeId(Address.class);
    PersistenceTypeHandler<Binary, ?> handler = registry.lookupTypeHandler(typeId);
    System.out.println(handler.allMembers());
----

The above snippet retrieves the _handler_ that was used to store our `Address` class.  The last line prints out the property names in the order they are stored within the binary format.

Based on that, we can create a `BinaryLegacyTypeHandler` that can create an instance of _Address_ with the stored data.

----
private static class AddressLegacyTypeMapper extends BinaryLegacyTypeHandler.AbstractCustom<Address> {

        // This is the order of the old class in the binary format
        // city - postalCode - streetName - id

        private static final long BINARY_OFFSET_city = 0;
        private static final long BINARY_OFFSET_postalCode = BINARY_OFFSET_city + Binary.objectIdByteLength();
        private static final long BINARY_OFFSET_streetName = BINARY_OFFSET_postalCode + Binary.objectIdByteLength();
        private static final long BINARY_OFFSET_id = BINARY_OFFSET_streetName + Binary.objectIdByteLength();


        protected AddressLegacyTypeMapper() {
            super(Address.class,
                    X.List());  // No items needed here for this case
        }

        @Override
        public void iterateLoadableReferences(Binary data, PersistenceReferenceLoader iterator) {
            // No actions needed in this case
        }

        @Override
        public Address create(Binary data, PersistenceLoadHandler handler) {
            return new Address();
        }

        @Override
        public void updateState(Binary data, Address instance, PersistenceLoadHandler handler) {

            Long id = data.read_long(BINARY_OFFSET_id);
            String city = (String) handler.lookupObject(data.read_long(BINARY_OFFSET_city));
            String postalCode = (String) handler.lookupObject(data.read_long(BINARY_OFFSET_postalCode));
            String streetName = (String) handler.lookupObject(data.read_long(BINARY_OFFSET_streetName));

            instance.setId(id);
            instance.setCity(city);
            instance.setPostalCode(postalCode);
            instance.setStreet(streetName);
        }

        @Override
        public boolean hasPersistedReferences() {
            return false;
        }

        @Override
        public boolean hasVaryingPersistedLengthInstances() {
            return false;
        }
    }
----
The important here is to calculate the offsets of the properties correctly. We start at position 0 and add an Object reference for each Object (like Strings or other objects) to the length each time.

For our long property id, we could use `Long.BYTES` to know how much space it takes. Here we don't need it since it is the last property.

Within the constructor, we do not need to define the different properties since we don't need multiple versions.  The `create()` method can be used to create an empty instance of our object, and the `updateState()` method can be used to read the populated objects from the binary data and set the property values.

With this mapper, it doesn't matter if we renamed the class or moved it to another package. We only read the binary structure and create an object instance out of it. It doesn't matter what class was used to write the binary data.

== Advanced topics

=== Type handler

??? FIXME Example for a custom Type Handler


=== ClassLoader Provider

??? FIXME  foundation.setClassLoaderProvider();

=== Change Byte Order

??? FIXME  setTargetByteOrder();

== TBD

??? What are the scenarios how the `setSerializerTypeInfoStrategyCreator` can be used?


Are these internal methods or how can they be used by the user

- SerializerFoundation.executeTypeHandlerRegistration()
- SerializerFoundation.createPersistenceManager()



What is the difference between

- setFieldEvaluatorPersistable();
- setFieldEvaluatorPersister();



Any scenario where it is useful that the user uses this?

- setTypeSimilarity();



??? Are there any usage scenarios for

- foundation.registerCustomInstantiator();


Any of these methods that the user should be using, or just for internal usage.

- setObjectRegistry();
- setTypeRegistry();
- setInstanceDispatcher();
- setObjectManager();
- setStorerCreator();
- setTypeHandlerManager();
- setTypeManager();
- setTypeHandlerCreatorLookup();
- setTypeHandlerCreator();
- setTypeAnalyzer();
- setTypeResolver();
- setTypeHandlerRegistry();
- setTypeHandlerProvider();
- setRegistererCreator();
- setBuilderCreator();
- setPersister();
- setTypeDictionaryCreator();
- setTypeDictionaryParser();
- setTypeLineageCreator();
- setTypeMismatchValidator();
- setTypeDescriptionBuilder();
- setTypeEvaluatorPersistable();
- setBufferSizeProvider();
- setFieldFixedLengthResolver();
- setTypeNameMapper();
- setFieldEvaluatorEnum();
- setFieldEvaluatorCollection();
- setReferenceFieldEagerEvaluator();
- setRootResolverProvider();
- setRootReferenceProvider();
- setLambdaTypeRecognizer();
- setAbstractTypeHandlerSearcher();
- setUnreachableTypeHandlerCreator();
- setLegacyTypeMapper();
- setRefactoringMappingProvider();
- setTypeDescriptionResolverProvider();
- setRefactoringLegacyTypeIdentifierBuilders();
- setRefactoringLegacyMemberIdentifierBuilders();
- setRefactoringCurrentMemberIdentifierBuilders();
- setLegacyMemberMatchingProvider();
- setLegacyTypeMappingResultor();
- setLegacyTypeHandlerCreator();
- setLegacyTypeHandlingListener();
- setSizedArrayLengthController();
- setInstantiator();
- setInstantiatorProvider();
- setSerializerTypeInfoStrategyCreator();
- setCustomTranslatorLookup();
- setTranslatorKeyBuilders());
- setValueTranslatorProvider();
- setValueTranslatorMappingProvider();
- setInstanceDispatcherLogic();
